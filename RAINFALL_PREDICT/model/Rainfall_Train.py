# -*- coding: utf-8 -*-
"""RainfallPredict.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1B0SlYLRAaEDqRM1AL_XJJBGeznDF6k-h
"""

import pandas as pd
from sklearn.pipeline import Pipeline
from sklearn.feature_selection import VarianceThreshold
from sklearn.preprocessing import StandardScaler
from sklearn.svm import SVC
from sklearn.model_selection import train_test_split
from sklearn.metrics import roc_auc_score
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier
from sklearn.tree import DecisionTreeClassifier
import seaborn as sns
import matplotlib.pyplot as plt

data = pd.read_csv("data/train.csv")

i,j = 0, 0
fig, ax = plt.subplots(4, 3, figsize=(18 , 11))
for colum in data.columns[:-1]:
    sns.histplot(data=data, x=colum, hue="rainfall", kde=True, ax=ax[j, i])
    if i < 2:
        i += 1
    else:
        i = 0
        j += 1
    plt.subplots_adjust(hspace = 0.5)

data.shape

plt.figure(figsize=(12, 10))
sns.heatmap(data=data.corr(), annot=True)

data.head(8)

data.describe()

data.info()

data.shape

data['season'] = data['day'] % 365

def get_season(day):
    month = (day % 365) // 30 + 1
    if month in [12, 1, 2]:
        return 0 #'Winter'
    elif month in [3, 4, 5]:
        return 1 #'Spring'
    elif month in [6, 7, 8]:
        return 2 #'Summer'
    else:
        return 3 #'Autumn'

data['season'] = data['day'].apply(get_season)
data = pd.get_dummies(data, columns=['season'], dtype=int)
data['temp_range'] = data['maxtemp'] - data['mintemp']
data['temp_dew_diff'] = data['temparature'] - data['dewpoint']

data, y = data.drop(["rainfall", "day", "id", "mintemp", "maxtemp"], axis=1), data["rainfall"]

norm = StandardScaler()
data2 = norm.fit_transform(data)
data = pd.DataFrame(data=data2, columns=data.columns)
svc = SVC(probability=True)
svc.fit(data, y)

xtrain, xtest, ytrain, ytest = train_test_split(data, y, test_size = 0.2, shuffle=True)

print("\nLEST TRY SOME MODELS \n")

pipeSVC = Pipeline(steps=[
("scaler", StandardScaler()),
("svc", SVC())
])
pipeSVC.fit(xtrain, ytrain)
print("SVC methood with RBF ", roc_auc_score(ytest, pipeSVC.predict(xtest)), "\n")

pipeSVCsig = Pipeline(steps=[
("scaler", StandardScaler()),
("svc", SVC(kernel="sigmoid"))
])
pipeSVCsig.fit(xtrain, ytrain)
print("SVC methood with Sigmoid Kernel", roc_auc_score(ytest, pipeSVCsig.predict(xtest)), "\n")

for i in range(1, 11):
    pipeVALc = Pipeline(steps=[
    ("scaler", StandardScaler()),
    ("svc", SVC(C=i))
    ])
    pipeVALc.fit(xtrain, ytrain)
    print(f"SVC methood with C = {i}", roc_auc_score(ytest, pipeVALc.predict(xtest)))


pipe2 = Pipeline(steps=[
("scaler", StandardScaler()),
("variance", VarianceThreshold(0.01)),
("LogisicRegression", LogisticRegression(penalty="l2"))
])
pipe2.fit(xtrain, ytrain)
print("\nLogistic Regression StScaler and antiVarMin", roc_auc_score(ytest, pipe2.predict(xtest)), "\n")

Dtree = DecisionTreeClassifier()
Dtree.fit(xtrain, ytrain)
print(f"Decision Tree Regressor with default, roc_auc_score = {roc_auc_score(ytest, Dtree.predict(xtest))}", "\n")

for i in range(1, 21):
    rfc = RandomForestClassifier(n_estimators=i)
    rfc.fit(xtrain, ytrain)
    print(f"Trees in RFS = {i}, roc_auc_score = {roc_auc_score(ytest, rfc.predict(xtest))}")

